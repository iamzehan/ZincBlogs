// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
  previewFeatures = ["views"]
}

datasource db {
  provider = "postgresql"
}

// Session 
model Session {
  id        String    @id @default(cuid())
  sid       String    @unique
  data      String
  expiresAt DateTime
}

model Author {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  profile Profile?
}
model Profile {
  id String @id @default(uuid())
  username String @unique
  firstName String
  lastName String

  // One to one relationship with the author
  authorId String @unique
  author Author @relation(fields: [authorId], references: [id], onDelete: Cascade)

  blog Blog[]
  @@index([id])
  @@index([authorId])
}

model Subscriber {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  username  String   @unique
  isVarified Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  comments Comments[]
}

// Temporary user storage
model PendingUser{
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  username  String   @unique
  createdAt DateTime @default(now())
  token EmailToken? 
}

// Email Verification Tokens
model EmailToken {
  id String @id @default(uuid())
  pendingId String @unique
  tokenHash String
  expiresAt DateTime

  pending PendingUser @relation(fields: [pendingId], references: [id], onDelete:Cascade)
}
model Blog {
  id String @id @default(uuid())
  title String
  content String

  // Timestamps to look after post timings
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Many to one relation with the author
  authorId String
  author Profile @relation(fields: [authorId], references: [authorId])
  // One to many relations
  tags TagsOnBlogs[]
  comments Comments[]
  publish PublishBlog?

  // indexing the author and the blog id
  @@index([id])
  @@index([authorId])
}

model PublishBlog {
  id String @id @default(uuid())
  blogId String @unique
  status Boolean @default(false)
  
  blog Blog @relation(fields: [blogId], references: [id], onDelete: Cascade)
}
// One blog can have many comments
model Comments {
  id String @id @default(uuid())
  content String
  blogId String
  userId String
  blog Blog @relation(fields: [blogId], references: [id])
  owner Subscriber @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([blogId])
  @@index([userId])
}

// One blog can have many tags
model Tags {
  id String @id @default(uuid())
  tag String @unique
  // but one tag can also belong to many blogs
  blog TagsOnBlogs[]
}

// Relation table for tags belonging to a blog
model TagsOnBlogs {
  tagId String
  blogId String
  
  // tags and blogs when deleted the entry will be deleted as well
  tag Tags @relation(fields: [tagId], references: [id], onDelete: Cascade)
  blog Blog @relation(fields: [blogId], references: [id], onDelete: Cascade)

  @@id([tagId, blogId])       // composite primary key
  @@index([blogId])
  @@index([tagId])
}

// Images 
model Images {
  id          Int      @id @default(autoincrement())
  url         String
  public_id   String   @unique
  filename    String
  created_at  DateTime @default(now())
  @@index([public_id])
}
// The following view is created so it's easier to use blog titles on the side navigation
view BlogTitles{
  id String @unique
  title String
}